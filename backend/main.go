package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"path/filepath"
)

// Config holding the app state
type Config struct {
	IsDev      bool
	ViteOrigin string
	WebRoot    string
	Manifest   map[string]ManifestEntry
}

// ManifestEntry represents a file in manifest.json
type ManifestEntry struct {
	File    string   `json:"file"`
	Src     string   `json:"src"`
	Css     []string `json:"css"`
	IsEntry bool     `json:"isEntry"`
}

var config Config

// DataProviderFunc processes the request and returns data for the template.
type DataProviderFunc func(r *http.Request) map[string]interface{}

// Page represents a registered page
type Page struct {
	Templates []string
	DataFunc  DataProviderFunc
}

func main() {
	// 1. Configuration
	// Determine if we are in dev mode (simplification: assume dev if env var not set)
	env := os.Getenv("APP_ENV")
	certFile := os.Getenv("CERT_FILE")
	keyFile := os.Getenv("KEY_FILE")
	domainName := os.Getenv("DOMAIN_NAME")

	config.IsDev = env != "production"
	config.ViteOrigin = "http://localhost:5173" // Default Vite port

	// Paths
	cwd, _ := os.Getwd()
	if config.IsDev {
		config.WebRoot = filepath.Join(cwd, "web", "src")
	} else {
		config.WebRoot = filepath.Join(cwd, "web", "out")
		loadManifest(filepath.Join(config.WebRoot, ".vite", "manifest.json"))
	}

	// 2. Register Pages

	// Home Page
	registerPage("/", []string{"base.html", "index.html"}, func(r *http.Request) map[string]interface{} {
		return map[string]interface{}{
			"Title": "Prismanis - Home",
		}
	})

	// Prismanis Page
	registerPage("/prismanis", []string{"base.html", "prismanis.html"}, func(r *http.Request) map[string]interface{} {
		return map[string]interface{}{
			"Title":    "Prismanis - Canvas",
			"ViteHead": generateViteTags("ts/main.ts", "ts/prismanis/index.ts"),
		}
	})
	// Serve static files
	fs := http.FileServer(http.Dir(config.WebRoot))
	http.Handle("/static/", fs)

	// Favicon
	http.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/static/assets/img/favicon.ico", http.StatusMovedPermanently)
	})

	// Serve built assets in production
	if !config.IsDev {
		http.Handle("/assets/", fs) // Vite builds to /assets inside outDir
	}

	// 3. Start Server
	devPort := ":443"
	fmt.Printf("Server starting on http://localhost%s (Mode: %s)\n", devPort, map[bool]string{true: "Development", false: "Production"}[config.IsDev])
	if config.IsDev {
		fmt.Printf("Ensure 'npm run dev' is running in another terminal.\n")
	}
	if !config.IsDev && certFile != "" && keyFile != "" && domainName != "" {
		// Redirect HTTP to HTTPS
		go func() {
			http.ListenAndServe(":80", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				http.Redirect(w, r, "https://"+domainName+r.RequestURI, http.StatusMovedPermanently)
			}))
		}()
		fmt.Printf("Running with TLS on https://%s\n", domainName)
		log.Fatal(http.ListenAndServeTLS(":443", certFile, keyFile, nil))
		return
	} else {
		fmt.Printf("Warning: TLS not configured, running over HTTP.\n")
		log.Fatal(http.ListenAndServe(devPort, nil))
	}
}

// registerPage is a helper to clean up main() and standardize page registration
func registerPage(path string, templateFiles []string, dataFunc DataProviderFunc) {
	http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
		// 1. Resolve full paths for templates
		var fullPaths []string
		for _, file := range templateFiles {
			fullPaths = append(fullPaths, filepath.Join(config.WebRoot, "templates", file))
		}

		// 2. Parse Templates
		// In dev: Parse on every request (easy reloading)
		// In prod: We could cache this, but keeping it simple for now as requested
		tmpl, err := template.ParseFiles(fullPaths...)
		if err != nil {
			http.Error(w, "Could not load templates: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 3. Prepare Data
		// Base data available to all pages
		data := map[string]interface{}{
			"ViteHead": generateViteTags("ts/main.ts"),
			"IsDev":    config.IsDev,
		}

		// Merge page-specific data
		if dataFunc != nil {
			pageData := dataFunc(r)
			for k, v := range pageData {
				data[k] = v
			}
		}

		// 4. Render
		// We execute "base.html" by default as the entry point
		err = tmpl.ExecuteTemplate(w, "base.html", data)
		if err != nil {
			log.Printf("Template execution error: %v", err)
		}
	})
}

// loadManifest reads the manifest.json file generated by Vite build
func loadManifest(path string) {
	data, err := os.ReadFile(path)
	if err != nil {
		// Try fallback path just in case (older vite versions put it in root of outDir)
		fallback := filepath.Join(filepath.Dir(filepath.Dir(path)), "manifest.json")
		data, err = os.ReadFile(fallback)
		if err != nil {
			log.Printf("Warning: Could not read manifest.json at %s: %v", path, err)
			return
		}
	}

	config.Manifest = make(map[string]ManifestEntry)
	if err := json.Unmarshal(data, &config.Manifest); err != nil {
		log.Printf("Error parsing manifest: %v", err)
	}
}

// generateViteTags creates script/link tags for Dev or Prod
func generateViteTags(entryPoints ...string) template.HTML {
	var html string

	if config.IsDev {
		// Development: Proxy to Vite Dev Server
		html += fmt.Sprintf(`<script type="module" src="%s/@vite/client"></script>`, config.ViteOrigin)
		for _, entry := range entryPoints {
			html += fmt.Sprintf(`<script type="module" src="%s/%s"></script>`, config.ViteOrigin, entry)
		}
		return template.HTML(html)
	}

	// Production: Look up in manifest
	// Note: Vite manifest keys are relative to source root (e.g. "ts/main.ts")
	for _, entryPoint := range entryPoints {
		entry, ok := config.Manifest[entryPoint]
		if !ok {
			html += fmt.Sprintf("<!-- Vite entry '%s' not found in manifest -->", entryPoint)
			continue
		}

		html += fmt.Sprintf(`<script type="module" src="/%s"></script>`, entry.File)

		// Add CSS chunks
		for _, cssFile := range entry.Css {
			html += fmt.Sprintf(`<link rel="stylesheet" href="/%s">`, cssFile)
		}
	}

	return template.HTML(html)
}
